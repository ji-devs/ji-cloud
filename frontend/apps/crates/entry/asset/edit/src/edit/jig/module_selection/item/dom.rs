use super::ModuleSelectionItem;
use components::overlay::handle::OverlayHandle;
use dominator::{clone, html, with_node, Dom};
use futures_signals::signal::SignalExt;
use std::rc::Rc;
use utils::{events, unwrap::UnwrapJiExt};
use web_sys::HtmlElement;

const STR_AUTOGENERATED_CONTENT: &str = "Automatically generated game with your content";
const STR_HAS_SCORING: &str = "This module supports scoring";

impl ModuleSelectionItem {
    pub fn render(self: Rc<Self>) -> Dom {
        let state = self;
        html!("jig-edit-module-card", {
            .prop("slot", "modules")
            .prop("module", state.kind.as_str())
            .event(clone!(state => move |_: events::PointerEnter| {
                state.hover.set(true);
            }))
            .event(clone!(state => move |_: events::PointerLeave| {
                state.hover.set(false);
            }))
            .event(clone!(state => move |evt: events::PointerDown| {
                if evt.is_primary() {
                    let elem = evt.dyn_target().unwrap_ji();
                    state.on_pointer_down(&elem, evt.x(), evt.y());
                }
            }))
            .apply_if(state.kind.has_scoring(), clone!(state => move |dom| {
                dom.child(html!("img-ui", {
                    .prop("slot", "extra-left")
                    .prop("draggable", false)
                    .prop("path", "module/_common/edit/scoring.svg")
                    .event(clone!(state => move |_: events::PointerEnter| {
                        state.show_scoring_tooltip.set(true);
                    }))
                    .event(clone!(state => move |_: events::PointerLeave| {
                        state.show_scoring_tooltip.set(false);
                    }))
                    .with_node!(elem => {
                        .child_signal(state.show_scoring_tooltip.signal_cloned().map(clone!(elem => move |show_tooltip| {
                            match show_tooltip {
                                false => None,
                                true => Some(
                                    html!("empty-fragment" => HtmlElement, {
                                        .apply(OverlayHandle::lifecycle(
                                            clone!(elem => move || {
                                                html!("overlay-tooltip-info", {
                                                    .prop("target", &elem)
                                                    .prop("color", "light-orange")
                                                    .attr("targetAnchor", "bm")
                                                    .attr("contentAnchor", "tm")
                                                    .prop("closeable", false)
                                                    .prop("strategy", "track")
                                                    .prop("removeMargins", true)
                                                    // This didn't seem worth creating a whole new
                                                    // element for the tooltip content
                                                    .child(html!("span", {
                                                        .prop("slot", "body")
                                                        .prop("textContent", STR_HAS_SCORING)
                                                        .style("color", "var(--dark-gray-6)")
                                                    }))
                                                })
                                            })
                                        ))
                                    })
                                ),
                            }
                        })))
                    })
                }))
            }))
            .apply_if(state.kind.autogenerated(), clone!(state => move |dom| {
                dom.child(html!("img-ui", {
                    .prop("slot", "extra-right")
                    .prop("draggable", false)
                    .prop("path", "module/_common/edit/magic-wand.svg")
                    .prop("hoverPath", "module/_common/edit/magic-wand-hover.svg")
                    .event(clone!(state => move |_: events::PointerEnter| {
                        state.show_autogen_tooltip.set(true);
                    }))
                    .event(clone!(state => move |_: events::PointerLeave| {
                        state.show_autogen_tooltip.set(false);
                    }))
                    .with_node!(elem => {
                        .child_signal(state.show_autogen_tooltip.signal_cloned().map(clone!(elem => move |show_tooltip| {
                            match show_tooltip {
                                false => None,
                                true => Some(
                                    html!("empty-fragment" => HtmlElement, {
                                        .apply(OverlayHandle::lifecycle(
                                            clone!(elem => move || {
                                                html!("overlay-tooltip-info", {
                                                    .prop("target", &elem)
                                                    .prop("color", "light-orange")
                                                    .attr("targetAnchor", "bm")
                                                    .attr("contentAnchor", "tm")
                                                    .prop("closeable", false)
                                                    .prop("strategy", "track")
                                                    .prop("removeMargins", true)
                                                    // This didn't seem worth creating a whole new
                                                    // element for the tooltip content
                                                    .child(html!("span", {
                                                        .prop("slot", "body")
                                                        .prop("textContent", STR_AUTOGENERATED_CONTENT)
                                                        .style("color", "var(--dark-gray-6)")
                                                    }))
                                                })
                                            })
                                        ))
                                    })
                                ),
                            }
                        })))
                    })
                }))
            }))
            .child(html!("img-ui", {
                .prop("slot", "stationery")
                .prop("draggable", false)
                .prop_signal("path", state.hover_or_drag_signal().map(clone!(state => move |hover| {
                    let suffix = match hover {
                        true => "-hover",
                        false => "",
                    };
                    format!("entry/jig/modules/large/{}{}.svg", state.kind.as_str(), suffix)
                })))
                .style_signal("filter", state.module_selection_state.drag.signal_ref(clone!(state => move |drag| {
                    match drag {
                        Some(drag) if drag.data == state.kind => "grayscale(100%) opacity(0.5)",
                        _ => "none",
                    }
                })))
                .style("touch-action", "none")
            }))
        })
    }
}
