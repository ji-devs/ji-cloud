use super::state::*;
use components::overlay::handle::OverlayHandle;
use dominator::{clone, html, with_node, Dom};
use futures_signals::signal::SignalExt;
use shared::domain::jig::ModuleKind;
use std::rc::Rc;
use utils::{events, unwrap::UnwrapJiExt};
use web_sys::HtmlElement;

const STR_AUTOGENERATED_CONTENT: &str = "Automatically generated game with your content";

pub struct ModuleDom {}

impl ModuleDom {
    pub fn render(kind: ModuleKind) -> Dom {
        let state = Rc::new(State::new(kind));

        html!("jig-edit-module-card", {
            .property("slot", "modules")
            .property("module", kind.as_str())
            .event(clone!(state => move |_: events::PointerEnter| {
                state.hover.set(true);
            }))
            .event(clone!(state => move |_: events::PointerLeave| {
                state.hover.set(false);
            }))
            .event(clone!(state => move |evt: events::PointerDown| {
                let elem = evt.dyn_target().unwrap_ji();
                state.on_pointer_down(&elem, evt.x(), evt.y());
            }))
            .apply_if(kind.autogenerated(), clone!(state => move |dom| {
                dom.child(html!("img-ui", {
                    .property("slot", "extra")
                    .property("draggable", false)
                    .property("path", "module/_common/edit/magic-wand.svg")
                    .property("hoverPath", "module/_common/edit/magic-wand-hover.svg")
                    .event(clone!(state => move |_: events::PointerEnter| {
                        state.show_autogen_tooltip.set(true);
                    }))
                    .event(clone!(state => move |_: events::PointerLeave| {
                        state.show_autogen_tooltip.set(false);
                    }))
                    .with_node!(elem => {
                        .child_signal(state.show_autogen_tooltip.signal_cloned().map(clone!(elem => move |show_tooltip| {
                            match show_tooltip {
                                false => None,
                                true => Some(
                                    html!("empty-fragment" => HtmlElement, {
                                        .apply(OverlayHandle::lifecycle(
                                            clone!(elem => move || {
                                                html!("overlay-tooltip-info", {
                                                    .property("target", &elem)
                                                    .property("color", "light-orange")
                                                    .attribute("targetAnchor", "bm")
                                                    .attribute("contentAnchor", "tm")
                                                    .property("closeable", false)
                                                    .property("strategy", "track")
                                                    .property("removeMargins", true)
                                                    // This didn't seem worth creating a whole new
                                                    // element for the tooltip content
                                                    .child(html!("span", {
                                                        .property("slot", "body")
                                                        .property("textContent", STR_AUTOGENERATED_CONTENT)
                                                        .style("color", "var(--dark-gray-6)")
                                                    }))
                                                })
                                            })
                                        ))
                                    })
                                ),
                            }
                        })))
                    })
                }))
            }))
            .child(html!("img-ui", {
                .property("slot", "stationery")
                .property("draggable", false)
                .property_signal("path", state.hover_or_drag_signal().map(clone!(state => move |hover| {
                    let suffix = match hover {
                        true => "-hover",
                        false => "",
                    };
                    format!("entry/jig/modules/large/{}{}.svg", state.kind.as_str(), suffix)
                })))
                .style_signal("filter", state.drag.signal_ref(|drag| {
                    match drag {
                        Some(_) => "grayscale(100%) opacity(0.5)",
                        None => "none",
                    }
                }))
                .style("touch-action", "none")
            }))
            .child_signal(state.drag.signal_ref(clone!(state => move|drag| {
                drag.as_ref().map(|drag| {
                    html!("img-ui", {
                        .property("slot", "dragged")
                        .property("path", &format!("entry/jig/modules/large/{}-hover.svg", state.kind.as_str()))
                        .style_signal("transform", drag.transform_signal())
                        .global_event(clone!(state, drag => move |evt: events::PointerMove| {
                            state.on_pointer_move(&drag, evt.x(), evt.y());
                        }))
                        .global_event(clone!(state => move |evt: events::PointerUp| {
                            state.on_pointer_up(evt.x(), evt.y());
                        }))
                        .global_event(clone!(state => move |_:events::PointerCancel| {
                            state.stop_drag();
                        }))
                    })
                })
            })))
        })
    }
}
